import sys

from uuid import UUID

# def tokenize(str_line):
#     if isinstance(str_line, str):
#         str_line = str_line.rstrip('\n') # remove trailing EOL
#     else:
#         return None

# "date", "uuid", "int", "float"

# def val2date(str_in):
#     try:
#         dt = dup.parse(str_in)
#     except:
#         dt = False
#     return dt
#
# def val2uuid(str_in):
#     lst_valid = list()
#     for n in (1,2,3,4):
#         if str_in[14]==n and str_in == UUID(str_in, version=n):
#             lst_valid.append(n)
#         else:
#             pass
#     if len(lst_valid) > 0:
#         return True
#     else:
#         return False
#
# def val2int(str_in):
#     ret = str_in
#     return ret
#
# def val2int(str_in):
#     ret = str_in
#     return ret

def all_is_uuid(lst_in):
    """Return True if all members of input list can be converted to valid uuid,
    otherwise returns False."""
    return False

def all_is_date(lst_in):
    """Return True if all members of input list can be converted to valid date,
    otherwise returns False."""
    num_of_empt = 0
    num_of_true = 0
    for itm in lst_in:
        if itm == '':
            num_of_true += 1
            num_of_empt += 1
        else:
            try:
                dt = dup.parse(itm)
                num_of_true += 1
                print " parse {} as {]".format(itm,dt)
            except:
                pass  # print "Can't pass as date:", itm
    if num_of_true == len(lst_in) and num_of_empt != len(lst_in):
        return True
    else:
        return False

def all_is_int(lst_in):
    """Return True if all members of input list can be converted to valid integer,
    otherwise returns False."""
    num_of_empt = 0
    num_of_true = 0
    for itm in lst_in:
        if itm == '':
            num_of_true += 1
            num_of_empt += 1
        else:
            try:
                num_val = int(itm)
                num_of_true += 1
            except:
                pass
    if num_of_true == len(lst_in) and num_of_empt != len(lst_in):
        return True
    else:
        return False

def all_is_float(lst_in):
    """Return True if all members of input list can be converted to valid float,
    otherwise returns False."""
    """Return True if all members of input list can be converted to valid integer,
    otherwise returns False."""
    num_of_empt = 0
    num_of_true = 0
    for itm in lst_in:
        if itm == '':
            num_of_true += 1
            num_of_empt += 1
        else:
            try:
                num_val = float(itm)
                num_of_true += 1
            except:
                pass
    if num_of_true == len(lst_in) and num_of_empt != len(lst_in):
        return True
    else:
        return False

def make_sql_create_table(str_tab_name, lst_field_names, lst_field_types):
    str_tab_name = "imports."+str_tab_name
    print "tabname:", str(type(str_tab_name)), str_tab_name
    print "fldname:", str(type(lst_field_names)), lst_field_names
    print "fldtype:", str(type(lst_field_types)), lst_field_types
    #
    str_sql = "-- Create table, generated by csv-alyser\n"
    str_sql += "-- DROP TABLE IF EXISTS {};\n".format(str_tab_name)
    str_sql += "\nCREATE TABLE {} (\n".format(str_tab_name)
    #  a_uuid uuid, -- uuid
    #  a_int bigint,
    #  a_float real,
    #  a_date timestamp without time zone,
    #  a_str character varying
    # )"
    if len(lst_field_names) == len(lst_field_types):
        for i in range(len(lst_field_names)):
            if lst_field_types[i] == 'str':
                str_sql += '"{}" character varying,\n'.format(lst_field_names[i])
            if lst_field_types[i] == 'int':
                str_sql += '"{}" bigint,\n'.format(lst_field_names[i])
            if lst_field_types[i] == 'float':
                str_sql += '"{}" real,\n'.format(lst_field_names[i])
            if lst_field_types[i] == 'date':
                str_sql += '"{}" timestamp without time zone,\n'.format(lst_field_names[i])
            if lst_field_types[i] == 'uuid':
                str_sql += '"{}" uuid,\n'.format(lst_field_names[i])
        # remove the last ',' and add a ');'
        str_sql = str_sql.rstrip('\n').rstrip(',')
        str_sql += "\n);"
        print "\n" + str_sql + "\n"
    else:
        print " - make_sql_create_table requires to lists of same length..."


if __name__ == '__main__':

    # Hardcoded - to be later converted to command line parameters
    chr_pref_deli = "\t" # default = None
    str_file_name = "/home/martin/MEGA/Snaps_HDD/DATA/Forekomster/GBIF_org/2017-10-08/GBIF_plant.csv"
    str_table_name = "Snaps"

    print "Reading file..."
    with open(str_file_name, 'r') as csvfile:
        los_long = csvfile.readlines()
    print "Processing {} lines of information...".format(len(los_long))

    #for line in los_long:
    #    pass#tokenize(line) - Early time pass...

    los_top = los_long#[:1024]

    ##print "Top:"
    ##for itm in los_top:
    ##    print itm.strip()

    # Find correct delimiter
    lst_pde = (",", ".", ";", ":", " ", "\t") # list of potential delimiters
    dic_pde = dict()
    lst_gde = list() # list of good delimiters
    for de in lst_pde:
        dic_pde[de] = list()
        for itm in los_top:
            dic_pde[de].append(itm.count(de))
    for de in dic_pde.keys():
        valid = len(set(dic_pde[de]))==1
        print de, ":", str(valid)
        if valid:
            lst_gde.append(de)
    print "Good delimiters: " + str(lst_gde)
    if len(lst_gde) == 1:
        deli = lst_gde[0]
    else:
        print "No conclusive delimiter found... "
        if chr_pref_deli:
            if chr_pref_deli in lst_gde:
                deli = chr_pref_deli
                print "Falling back on prefered delimiter"
            else:
                print "No prefered delimiter indicated - Exiting"
                sys.exit(0)
    # validate same number all the way
    lst_delis = list((str_in.count(deli) for str_in in los_long))
    num_delis = len(set(lst_delis))
    print "Number of delimiters per line:", set(lst_delis)
    print "Number of different number of delimiters per line (should be 1):", num_delis
    if num_delis == 1:
        cols = lst_delis[0]+1
    else:
        #print "stat: {}".format(lst_delis)
        for cnt in set(lst_delis):
            print "Cnt: {} seen {} times".format(cnt, lst_delis.count(cnt))
        print "Exiting due to delimiter count conflict... Please fix your data!"
        ## it's 1095897881
        for str_in in los_long:
            if str_in.count(deli) != 43:
                print str_in
        ##
        sys.exit(999)
    print "Cols:", cols

    # Tokenize and cross-hatch
    lolot_top = list((str.split(deli) for str in los_top))
    lot_lin1 = list(str_x.strip() for str_x in lolot_top[0]) # First line is special, as it may be a header
    lolot_lins = lolot_top[1:]
    lolot_cols = list()
    for i in range(len(lolot_lins[0])): # Create empty lists
        lolot_cols.append(list())
    for lot_lin in lolot_lins:
        for j in range(len(lot_lin)):
            lolot_cols[j].append(lot_lin[j])

    # Look for types
    lst_types = list()
    for k in range(len(lolot_cols)):
        col = lolot_cols[k]
        if all_is_uuid(col):
            lst_types.append("uuid")
        elif all_is_int(col):
            lst_types.append("int")
        elif all_is_float(col):
            lst_types.append("float")
        elif all_is_date(col):
            lst_types.append("date")
        else:
            lst_types.append("str")
    for i in range(len(lot_lin1)):
        print lst_types[i], lot_lin1[i]

    # create a sql 'create table' block
    str_tab_name = str_table_name.lower()
    lst_field_names = list((str_x.lower() for str_x in list(lot_lin1)))
    lst_field_types = list(lst_types)
    str_sql = make_sql_create_table(str_tab_name, lst_field_names, lst_field_types)


    print "Done..."
