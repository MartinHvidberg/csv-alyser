import sys

from uuid import UUID



def all_is_uuid(lst_in):
    """Return True if all members of input list can be converted to valid uuid,
    otherwise returns False."""
    return False

def all_is_date(lst_in):
    """Return True if all members of input list can be converted to valid date,
    otherwise returns False."""
    num_of_empt = 0
    num_of_true = 0
    for itm in lst_in:
        if itm == '':
            num_of_true += 1
            num_of_empt += 1
        else:
            try:
                dt = dup.parse(itm)
                num_of_true += 1
                print " parse {} as {]".format(itm,dt)
            except:
                pass  # print "Can't pass as date:", itm
    if num_of_true == len(lst_in) and num_of_empt != len(lst_in):
        return True
    else:
        return False

def all_is_int(lst_in):
    """Return True if all members of input list can be converted to valid integer,
    otherwise returns False."""
    num_of_empt = 0
    num_of_true = 0
    for itm in lst_in:
        if itm == '':
            num_of_true += 1
            num_of_empt += 1
        else:
            try:
                num_val = int(itm)
                num_of_true += 1
            except:
                pass
    if num_of_true == len(lst_in) and num_of_empt != len(lst_in):
        return True
    else:
        return False

def all_is_float(lst_in):
    """Return True if all members of input list can be converted to valid float,
    otherwise returns False."""
    """Return True if all members of input list can be converted to valid integer,
    otherwise returns False."""
    num_of_empt = 0
    num_of_true = 0
    for itm in lst_in:
        if itm == '':
            num_of_true += 1
            num_of_empt += 1
        else:
            try:
                num_val = float(itm)
                num_of_true += 1
            except:
                pass
    if num_of_true == len(lst_in) and num_of_empt != len(lst_in):
        return True
    else:
        return False

def find_usable_delimitor(los_top):
    lst_pde = (",", ".", ";", ":", " ", "\t") # list of potential delimiters
    dic_pde = dict()
    lst_gde = list() # list of good delimiters
    for de in lst_pde:
        dic_pde[de] = list()
        for itm in los_top:
            dic_pde[de].append(itm.count(de))
    for de in dic_pde.keys():
        valid = len(set(dic_pde[de]))==1 and dic_pde[de][0] != 0
        print de, ":", str(valid), sorted(list(set(dic_pde[de])))
        if valid:
            lst_gde.append(de)
    print "Good delimiters: " + str(lst_gde)
    if len(lst_gde) == 1:
        return lst_gde[0]
    else:
        print "No conclusive delimiter found... {}".format(lst_gde)
        sys.exit(999)

def validate_same_delimiter_count_in_all_lines(deli, los_long):
    lst_delis = list((str_in.count(deli) for str_in in los_long))
    print "Number of delimiters per line:", set(lst_delis)
    num_delis = len(set(lst_delis))
    print "Number of different number of delimiters per line (should be 1):", num_delis
    if num_delis == 1:
        cols = lst_delis[0]+1
    else:
        #print "stat: {}".format(lst_delis)
        for cnt in set(lst_delis):
            print "Cnt: {} seen {} times".format(cnt, lst_delis.count(cnt))
        print "Exiting due to delimiter count conflict... Please fix your data!"
        ## it's 1095897881
        for str_in in los_long:
            if str_in.count(deli) != 43:
                print str_in
        ##
        sys.exit(999)
    print "Cols:", cols


def make_sql_create_table(str_tab_name, lst_field_names, lst_field_types):
    str_tab_name = "imports."+str_tab_name
    print "tabname:", str(type(str_tab_name)), str_tab_name
    print "fldname:", str(type(lst_field_names)), lst_field_names
    print "fldtype:", str(type(lst_field_types)), lst_field_types
    #
    str_sql = "-- Create table, generated by csv-alyser\n"
    str_sql += "-- DROP TABLE IF EXISTS {};\n".format(str_tab_name)
    str_sql += "\nCREATE TABLE {} (\n".format(str_tab_name)
    #  a_uuid uuid, -- uuid
    #  a_int bigint,
    #  a_float real,
    #  a_date timestamp without time zone,
    #  a_str character varying
    # )"
    if len(lst_field_names) == len(lst_field_types):
        for i in range(len(lst_field_names)):
            if lst_field_types[i] == 'str':
                str_sql += '"{}" character varying,\n'.format(lst_field_names[i])
            if lst_field_types[i] == 'int':
                str_sql += '"{}" bigint,\n'.format(lst_field_names[i])
            if lst_field_types[i] == 'float':
                str_sql += '"{}" real,\n'.format(lst_field_names[i])
            if lst_field_types[i] == 'date':
                str_sql += '"{}" timestamp without time zone,\n'.format(lst_field_names[i])
            if lst_field_types[i] == 'uuid':
                str_sql += '"{}" uuid,\n'.format(lst_field_names[i])
        # remove the last ',' and add a ');'
        str_sql = str_sql.rstrip('\n').rstrip(',')
        str_sql += "\n);"
        print "\n" + str_sql + "\n"
    else:
        print " - make_sql_create_table requires to lists of same length..."


if __name__ == '__main__':

    # Hardcoded - to be later converted to command line parameters
    chr_pref_deli = "\t" # default = None
    str_file_name = "/home/martin/MEGA/Snaps_HDD/DATA/Forekomster/GBIF_org/2017-10-08/GBIF_plant.csv"
    str_file_name = "/home/martin/Work/AIS_DK/aisdk_20190208_samp.csv"
    str_file_name = r"../data/demo_checker.csv"
    str_table_name = "Samp"

    print("Reading file: {}".format(str_file_name))
    with open(str_file_name, 'r') as csvfile:
        los_long = csvfile.readlines()
    print "Processing {} lines of information...".format(len(los_long))

    los_top = los_long[:65536]  # assume this sample to reveal all variations

    deli = find_usable_delimitor(los_top)

    validate_same_delimiter_count_in_all_lines(deli, los_long)

    del los_long

    # Tokenize and cross-hatch
    lolot_top = list((str.split(deli) for str in los_top))
    lot_lin1 = list(str_x.strip() for str_x in lolot_top[0]) # First line is special, as it may be a header
    lolot_lins = lolot_top[1:]
    lolot_cols = list()
    for i in range(len(lolot_lins[0])): # Create empty lists
        lolot_cols.append(list())
    for lot_lin in lolot_lins:
        for j in range(len(lot_lin)):
            lolot_cols[j].append(lot_lin[j])

    # Look for types
    lst_types = list()
    for k in range(len(lolot_cols)):
        col = lolot_cols[k]
        if all_is_uuid(col):
            lst_types.append("uuid")
        elif all_is_int(col):
            lst_types.append("int")
        elif all_is_float(col):
            lst_types.append("float")
        elif all_is_date(col):
            lst_types.append("date")
        else:
            lst_types.append("str")
    for i in range(len(lot_lin1)):
        print lst_types[i], lot_lin1[i]

    # create a sql 'create table' block
    str_tab_name = str_table_name.lower()
    lst_field_names = list((str_x.lower() for str_x in list(lot_lin1)))
    lst_field_types = list(lst_types)
    str_sql = make_sql_create_table(str_tab_name, lst_field_names, lst_field_types)


    print "Done..."
